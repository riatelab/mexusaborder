---
title: "CARTOGRAPHIE AVEC R"
date: "Paris, 20 nov. 2019"
author: N. Lambert, R. Ysebaert
output:
  rmdformats::material:
    self_contained: false
    thumbnails: false
    lightbox: true
    gallery: true
    cards: false
    highlight: tango
---

<link rel="stylesheet" type="text/css" media="all" href="style.css" />

# Objectifs

Cartographier la frontière USA - Mexique

# Import des données et mise en fome

- Installation des packages utiles

```{r eval = TRUE}
library("sf")
library("rnaturalearth")
library("geojsonsf")
library("cartography")
library("cartogram")
library("leaflet")
library("SpatialPosition")
library("units")
library("OECD")
library("ggplot2")
```

- Import des géométries

```{r eval = TRUE}

# Pays (source : natural earth)
countries <- ne_countries(scale = 50, type = "countries", continent = NULL,
                          country = NULL, geounit = NULL, sovereignty = NULL,
                          returnclass = "sf")
countries <- countries[countries$adm0_a3 %in% c("MEX","USA"),]

# Mur de séparation (source : https://data.world/carlvlewis/border-fence-boundaries-u-s-mexico)
fences <- geojson_sf("data/data.world/border-fence.geojson")

# Rivières (source : natural earth)
rivers <- ne_download(scale = 50, type = "rivers_lake_centerlines", category = "physical", returnclass = "sf")

# Trait de côte (source : natural earth)
coastline <- ne_download(scale = 50, type = "coastline", category = "physical", returnclass = "sf")

# Océans (source : natural earth)
ocean <- ne_download(scale = 50, type = "ocean", category = "physical", returnclass = "sf")

```

- Mise en forme des géométries (emprise, projection)

```{r eval = TRUE}

# choix de la projection
prj <- "+proj=aea +lat_1=14.5 +lat_2=32.5 +lat_0=24 +lon_0=-105 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs"

countries <- st_transform(countries,crs = prj) 
fences <- st_transform(fences,crs = prj) 
rivers <- st_transform(rivers,crs = prj) 
coastline <- st_transform(coastline,crs = prj) 
ocean <- st_transform(ocean,crs = prj) 

# Choix de l'emprise (un peu de bidouille, pas optimal)

bb <- c(-1342784.0, -739750.5, 793341.2, 1317849.8)
d <- 100000
bbox <- st_as_sfc(st_bbox(c(xmin = bb[1]-2*d , xmax = bb[3]+2*d, ymax = bb[2]-d, ymin = bb[4]+d), crs = prj))
```

- Création d'un template cartographique

```{r eval = TRUE}
lay <- function(title = ""){
  authors <- "N. Lambert & R. Ysebaert, 2019\nData source: IOM, 2019 - Didelon, Vandermotten, Dessouroux, 2019"
  par(mar = c(0,0,1.2,0))
  plot(st_geometry(ocean), col= "#b8d5e3", border = NA, xlim = bb[c(1,3)], ylim = bb[c(2,4)])
  plot(st_geometry(countries) + c(-10000, -10000), col ="#827e6c50", border = NA, add= T)
  plot(st_geometry(countries), col= "#ede6bb", border = "white", cex = 0.5, add=T)
  plot(st_geometry(coastline), col= "#6d9cb3",lwd = 1 ,add= T)
  plot(st_geometry(rivers), col= "#6d9cb3",lwd = 1 ,add= T)
  plot(st_geometry(fences), col= "#3d3c3c",lwd = 3 ,add= T)
  layoutLayer(title = title,
              author =  authors,
              scale = 300, south = TRUE, frame = TRUE,
              col = "#6d9cb3", coltitle = "white")
}
lay("Template cartographique")
```

# Radiographie de la frontière

- Evolution du PIB dans le temps

```{r eval = TRUE}

as.data.frame(search_dataset("GDP", data = get_datasets()))

dstruc <- get_data_structure("PDB_LV")
str(dstruc, max.level = 2)

df <- get_dataset(dataset = "PDB_LV", filter = list(c("MEX", "USA","OECD"), 
                                                    "T_GDPPOP",
                                                    "CPC"))

df$obsTime <- as.numeric(df$obsTime)

qplot(data = df, x = obsTime, y = obsValue, color = LOCATION, geom = "line") +
  labs(x = NULL, y = "USD, current prices, current PPPs", color = NULL,
       title = "GDP per head of population")
```

- Evolution des moins de 20 ans dans le temps

```{r eval = TRUE}
as.data.frame(search_dataset("population", data = get_datasets()))
dstruc <- get_data_structure("POP_PROJ")

dstruc$VAR_DESC
dstruc$AGE

filter_list <- list(c("MEX","USA","OECD"),"TT","D1TTR5Y4")
df <- as.data.frame(get_dataset(dataset = "POP_PROJ", filter = filter_list))

df$obsTime <- as.numeric(df$obsTime)

qplot(data = df, x = obsTime, y = obsValue, color = LOCATION, geom = "line") +
  labs(x = NULL, y = "%", color = NULL,
       title = "Part de la population âgée de moins de 20 ans")
```

- Cartographie des ruptures spatiales

```{r eval = TRUE}

# --- admin level 12
subregions <- st_read(dsn = "data/regions/mex_us_admin_1.shp",options = "ENCODING=UTF-8",
                      stringsAsFactors = FALSE)

subregions <- st_transform(subregions,crs = prj) 


#  DATA -- PIB & demo (level 1-2)
pib <- read.csv("data/regions/PIB.csv", sep = "\t",encoding = "UTF-8", dec = ",",
                stringsAsFactors=FALSE)


pop <- read.csv("data/regions/POP.csv", sep = "\t", encoding = "UTF-8", dec = ",",
                stringsAsFactors=FALSE)


subregions <- merge (x = subregions, y = pib, 
                     by.x = "ID_ADMIN_1",
                     by.y = "ID_ADMIN",
                     all.x = TRUE)

subregions <- merge (x = subregions, y = pop, 
                     by.x = "ID_ADMIN_1",
                     by.y = "ID_ADMIN",
                     all.x = TRUE)
# Intersect with bounding box (pas optimal)
#bbox <- st_as_sfc(st_bbox(c(xmin = -1832288 , xmax = 1500000, ymax = 1450000, ymin = -830000), crs = prj))
#bboxocean <- st_as_sfc(st_bbox(c(xmin = -1342784, xmax = 93341.2, ymin = -739750.5, ymax = 1317850)))

subregions1 <- st_intersection(x = subregions, st_geometry(bbox))

```

- Indice de vieillessement

```{r eval = TRUE}

par(mar = c(0,0,1.2,0))

lay()

choroLayer(x = subregions1, var = "POP65_POP15",
           breaks = c(min(subregions1$POP65_POP15, na.rm = T),
                      20,25,35,50,65,
                      max(subregions1$POP65_POP15, na.rm = T)),
           col = carto.pal(pal1 = "green.pal", n1 = 3,
                           pal2 = "red.pal", n2 = 3),
           legend.pos = "left",
           legend.title.txt = "Rapport entre la\npopulation âgée de\nplus de 65 ans\net la population âgée\nde moins de 15 ans\nen 2015 (%)",
           border = NA,
           add = TRUE)

plot(st_geometry(coastline), col= "#6d9cb3",lwd = 1 ,add= T)

# Get borders
subregions.borders <- getBorders(subregions1)

discLayer(x = subregions.borders, df = subregions1,
          var = "POP65_POP15", col="black", nclass=3,
          method="equal", threshold = 0.4, sizemin = 0.5,
          sizemax = 10, type = "abs",legend.values.rnd = 0,
          legend.title.txt = "Discontinuités sur l'indice de veillissement 2015\n(différences absolues)",
          legend.pos = "bottomleft", add=TRUE)

layoutLayer(title = "Une barrière démographique... ",
            scale = 300, south = TRUE, frame = TRUE,
            col = "#6d9cb3", coltitle = "white")

```

- Produit intérieur brut
```{r eval = TRUE}

lay()

choroLayer(x = subregions1, var = "PIB100_2017",
           breaks = c(min(subregions1$PIB100_2017, na.rm = T),
                      75,90,100,125,150,200,
                      max(subregions1$PIB100_2017, na.rm = T)),
           col = carto.pal(pal1 = "red.pal", n1 = 3,
                           pal2 = "green.pal", n2 = 4),
           legend.pos = "left",
           legend.title.txt = "PIB par habitant 2017\n(100 = moyenne mondiale)",
           border = NA,
           add = TRUE)

plot(st_geometry(coastline), col= "#6d9cb3",lwd = 1 ,add= T)

# Get borders
discLayer(x = subregions.borders, df = subregions1,
          var = "PIB100_2017", col="black", nclass=3,
          method="equal", threshold = 0.2, sizemin = 0.5,
          sizemax = 10, type = "abs",legend.values.rnd = 0,
          legend.title.txt = "Discontinuités de PIB par habitant 2017\n(différences absolues)",
          legend.pos = "bottomleft", add=TRUE)



layoutLayer(title = "Doublé d'un mur de richesse... Mais quelles conséquences ?",
            scale = 300, south = TRUE, frame = TRUE,
            col = "#6d9cb3", coltitle = "white")

```

- Anamorphose

```{r eval = TRUE}
library(cartogram)
subregions <- st_cast(subregions, "MULTIPOLYGON")

subregions_cont <- cartogram_dorling(subregions,weight = "POP_2015")
subregions_cont <- cartogram_cont(subregions,weight = "POP_2015", itermax = 50)

choroLayer(x = subregions_cont, var = "PIB100_2017",
           breaks = c(min(subregions_cont$PIB100_2017, na.rm = T),
                      75,90,100,125,150,200,
                      max(subregions_cont$PIB100_2017, na.rm = T)),
           col = carto.pal(pal1 = "red.pal", n1 = 3,
                           pal2 = "green.pal", n2 = 5),
           legend.pos = "topleft",
           legend.title.txt = "PIB par habitant 2017\n(100 = moyenne mondiale)",
           border = "white")
```

- Border Control

```{r eval = TRUE}

library(osmdata)

# Convert bbox in WGS84
bbox <- st_transform(bbox, 4326)

# define and launch the query
opqbox <- opq(bbox = bbox , timeout = 5000)
opquery <- add_osm_feature(opq = opqbox, key = "barrier", value = "border_control")
feat <- osmdata_sf(opquery)

# Extraire les points qui répondent à la requête
featpt <- st_transform(feat$osm_points, prj)
featpt <- featpt[featpt[["barrier"]] %in% "border_control", ]

# Extraire les polygones qui répondent à la requête
featpo <- st_transform(feat$osm_polygons, prj)
st_geometry(featpo) <- st_centroid(st_geometry(featpo))
featpo$osm_id <- row.names(featpo)
featpt <- rbind(featpt[, c("osm_id", "geometry")], featpo[, c("osm_id", "geometry")])
poi_osm <- st_intersection(x = featpt, st_geometry(subregions1))

# Représentation des points extraits
lay()
plot(st_geometry(poi_osm), bg = "orange", col = "black", pch = 21, cex = 0.8, add = TRUE)

# Create grid 
grid <- st_make_grid(subregions1, cellsize = 50000)
grid <- st_sf(grid)

# Compter le nombre de postes de police par points de grille
grid$ncops <- lengths(st_covers(grid, poi_osm))
grid$dcops <- grid$ncops / set_units(st_area(grid), "km^2")

# Plusieurs façons de visualiser les résultats (tests)
grid_ncont <- cartogram_ncont(grid, "ncops")
plot(grid_ncont$geometry, col="red", add = T)

propSymbolsLayer(grid, var = "ncops", col = "red", symbols = "square", add = T,
                 legend.pos = "topright",
                 legend.title.txt = "Nombre de postes frontière\n(zones de 50km²)")

choroLayer(x = grid, var = "ncops",
           breaks = c(0.535, 5, 10,20,66),
           col = carto.pal(pal1 = "pink.pal", n1 = 4),
           legend.pos = "topright",
           legend.title.txt = "Nombre de postes frontière\n(zones de 50km²)",
           border = NA,
           add = TRUE)

```

# Migrations

Cartographies du nombre de migrants morts à la frontières

- Import (et mise en forme) des données de l'OIM

```{r eval = TRUE}
iom <- read.csv("data/iom/MissingMigrants-Global-2019-09-04T11-59-55.csv", stringsAsFactors = F)
iom <- iom[(iom$Location.Coordinates)!="",]

latlon <- matrix(as.numeric(unlist(strsplit(iom$Location.Coordinates, split = ", "))), ncol = 2, byrow = T)
colnames(latlon) <- c("lat", 'lon')
iom <- cbind(iom, latlon)
iom <- iom[,c("Web.ID","Reported.Year","Total.Dead.and.Missing","Number.of.Survivors","Region.of.Incident","lat","lon")]
colnames(iom) <- c("id","year","deads","survivors","region","latitude","longitude")
iom$deads <- as.numeric(iom$deads)
iom <- iom[!is.na(iom$deads),]
iom$latitude <- as.numeric(iom$latitude)
iom$longitude <- as.numeric(iom$longitude)
iom_sf <- st_as_sf(iom, coords = c("longitude", "latitude"), crs = 4326, agr = "constant")
iom_sf <- st_transform(iom_sf,crs = prj)
```

- Comparaison régionale

```{r eval = TRUE}
par(mar=c(10,8,4,2))
med <- aggregate(iom_sf$deads,list(iom_sf$region), sum, simplify = TRUE )
colnames(med) <- c("region","nb")
total <- round(sum(med$nb),-2)
cols <- rep("#ffbaba",length(med$region))
cols[c(7,15)] <- "red"
barplot(med$nb, ylab="Number of persons", names.arg=med$region, las=2, border="#991313",col=cols)
```

- Evolution temporelle

```{r eval = TRUE}
iom_sf <- iom_sf[iom_sf$region =="US-Mexico Border",]
st_bbox(iom_sf)
par(mar=c(5,8,4,2))
med <- aggregate(iom_sf$deads,list(iom_sf$year), sum, simplify = TRUE )
colnames(med) <- c("year","nb")
total <- round(sum(med$nb),-2)
med[med$year==2019,"year"] <- "2019*"
barplot(med$nb, xlab=paste0("Total over the perdiod: ",total,"\n(*) from January 1 to Sept. 3 2019"), ylab="Number of persons", names.arg=med$year,
        border="#991313",col=c("red","red","red","red","red","#ffbaba"))
```

- Carte de localisation

```{r eval = TRUE}
lay("USA-Mexico border")
plot(st_geometry(iom_sf), pch=20, col= "#eb3850", cex = 0.5, add=T)
```

- Symboles proportionnels

```{r eval = TRUE}
lay("USA-Mexico border")
propSymbolsLayer(x = iom_sf, var = "deads",
                 symbols = "circle", col =  "#eb3850",
                 legend.pos = "left", border = "black", lwd = 0.5,
                 legend.title.txt = "Dead\nand missing\nmigrants,\n2014 - 2019",
                 legend.style = "e")
```

- Cartogrammes de Dorling

```{r eval = TRUE}
iom_sf$m_weight <- 1
iom_sf$m_weight[iom_sf$deads > 1] <- 0.5
iom_sf$m_weight[iom_sf$deads >= 25] <- 0
deathsdor <- cartogram_dorling(x = st_jitter(iom_sf),weight = "deads", m_weight = iom_sf$m_weight, k = .4)

lay("USA-Mexico border")
plot(st_geometry(deathsdor), pch=20, col= "#eb3850", border ="#ede6bb", cex = 0.1, add=T)
plot(st_geometry(fences), col= "#3d3c3c", lwd = 3 ,add= T)
```

- Cartogrammes de Dorling (après désagrégation)

```{r eval = TRUE}
all <- iom_sf[,c("id","deads","year","geometry")]

iom_unique <- all[all$deads == 1,]
iom_multi <-  all[all$deads > 1,]

for (i in 1:dim(iom_multi)[1]){
nb <- as.numeric(iom_multi[i,"deads"])[1]
tmp <- iom_multi[i,]
tmp$deads <- 1
for (j in 1:nb){ iom_unique <- rbind(iom_unique,tmp)}
}

deathsdor2 <- cartogram_dorling(x = st_jitter(iom_unique),weight = "deads", k = .004)
lay("USA-Mexico border")
plot(st_geometry(deathsdor2), pch=20, col= "#eb3850", border ="#ede6bb", cex = 0.1, add=T)
plot(st_geometry(fences), col= "#3d3c3c", lwd = 3 ,add= T)
```

- Geoweb (leaflet)

```{r eval = TRUE}

iom <- read.csv("data/iom/MissingMigrants-Global-2019-09-04T11-59-55.csv", stringsAsFactors = F)
iom <- iom[(iom$Location.Coordinates)!="",]
iom <- iom[iom$Region.of.Incident =="US-Mexico Border",]
latlon <- matrix(as.numeric(unlist(strsplit(iom$Location.Coordinates, split = ", "))), ncol = 2, byrow = T)
colnames(latlon) <- c("lat", 'lon')
iom <- cbind(iom, latlon)
iom <- iom[,c("Reported.Year","Total.Dead.and.Missing","lat","lon","Location.Description","Cause.of.Death","Information.Source")]
colnames(iom) <- c("year","deads","lat","lon","location","cause","source")

fences <- geojson_sf("data/data.world/border-fence.geojson")

# Disaggregation

iom_unique <- iom[iom$deads == 1,]
iom_multi <-  iom[iom$deads > 1,]
for (i in 1:dim(iom_multi)[1]){
  nb <- as.numeric(iom_multi[i,"deads"])[1]
  tmp <- iom_multi[i,]
  tmp$deads <- 1
  for (j in 1:nb){ iom_unique <- rbind(iom_unique,tmp)}
}

iom <- iom_unique

pins <- makeIcon(
  iconUrl = "data/pin.svg",
  iconWidth = 30, iconHeight = 30,
  iconAnchorX = 15, iconAnchorY = 15
)

iom$label <- paste0(
                    "<h1>",iom$cause,"</h1>
                     <h3>year: </b>",iom$year,"<br/>
                     location: ",iom$location,"</h3>                      
                     <i>Source: ",iom$source,"</i>"
                    )

```


```{r eval = TRUE}

m <- leaflet(iom) %>%
  addProviderTiles(providers$Esri.WorldStreetMap) %>%
  setView(lng = -104, lat = 30, zoom = 06) %>%
  addMarkers(~lon, ~lat, popup = ~label, clusterOptions = markerClusterOptions(), icon = pins ) %>%
  addScaleBar(position = "bottomleft") %>%
addPolylines(data = fences, color = "black", weight = 7, opacity = 1)
m


```

# --- R infos ---

Version de R

```{r, eval=T, echo=T}
R.version
```

Session

```{r, eval=T, echo=T}
sessionInfo()
```


